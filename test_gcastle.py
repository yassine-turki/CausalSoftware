# -*- coding: utf-8 -*-
"""Test_gcastle.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-8yyiMzRYtwZCzWBhV4MUcX2JeUgufqj

# Imports
"""


import os
os.environ['CASTLE_BACKEND'] = 'pytorch'

from collections import OrderedDict

import numpy as np
import networkx as nx
import pandas as pd
import pydot
from IPython.display import Image, display

import castle
from castle.common import GraphDAG
from castle.metrics import MetricsDAG
from castle.datasets import IIDSimulation, DAG
from castle.algorithms import PC, GES, ICALiNGAM, GOLEM
from castle.common.priori_knowledge import PrioriKnowledge

import matplotlib.pyplot as plt

import sys

file_path = sys.argv[1] 
"""Get the data"""

#Loads dataset and checks if there are any NaN values and non numerical data
#Returns an np array of the values in the dataframe, and a list of labels

def load_and_check_data(file_path, dropna=False, drop_objects=False):
  data=pd.read_csv(file_path)
  cols_containing_nan = []

  # Check for NaN values in each column
  for col in data.columns:
      if data[col].isnull().any():
          cols_containing_nan.append(col)
  if len(cols_containing_nan) !=0:
    print("Columns with missing values:", cols_containing_nan)
    if dropna==False:
      print("Please remove missing values, or set dropna to True")
      return None
    else:
      data=data.dropna()

  #Check for non numerical data:

  object_columns = data.select_dtypes(include=['object']).columns
  if len(object_columns) > 0:
    print("Columns of object type found:", object_columns)
    if drop_objects==False:
      print("Please remove non numerical data, or set drop_objects to True")
    else:
      data=data.drop(columns=object_columns)

  return data.values, data.columns

def run_pc(data, labels, variant="original", alpha=0.05, ci_test="fisherz", priori_knowledge=None):
  """
  data: a pd dataframe

  variant : str
  A variant of PC-algorithm, one of [`original`, `stable`, `parallel`].

  alpha: float, default 0.05  Significance level.

  ci_test : str, callable ci_test method, if str, must be one of [`fisherz`, `g2`, `chi2`]
  See more: `castle.common.independence_tests.CITest`

  priori_knowledge: PrioriKnowledge: a class object PrioriKnowledge. In this case, we will just use a list of lists, symbolizing tiers.

  For example: [["income", "relationship"],["Sex", "workclass"]]. The first sublist is tier 1, the second tier 2. No path from tier 2 to tier 1 can exist.
  """
  if priori_knowledge is not None:
    node_map = {}
    for i, label in enumerate(labels):
        node_map[label] = i
    priori = PrioriKnowledge(data.shape[1])

    for i in range(len(priori_knowledge) - 1, 0, -1):  # iterating through tiers in reverse order
        for j in range(len(priori_knowledge[i])):  # iterating through the nodes in the current tier
            for k in range(i - 1, -1, -1):  # iterate over the previous tiers in reverse order
                for p in range(len(priori_knowledge[k])):  # iterating through the previous tier nodes
                    priori.add_forbidden_edge(node_map[priori_knowledge[i][j]], node_map[priori_knowledge[k][p]])

    # Adding forbidden edges within the same tier
    for i in range(len(priori_knowledge)):
        for j in range(len(priori_knowledge[i]) - 1):
            for k in range(j + 1, len(priori_knowledge[i])):
                priori.add_forbidden_edge(node_map[priori_knowledge[i][j]], node_map[priori_knowledge[i][k]])
  else:
    priori = None


  pc = PC(variant = variant, alpha = alpha, ci_test = ci_test, priori_knowledge = priori)
  pc.learn(data)
  return pc

def draw_graph(graph, labels, filename=None): # Draw the pydot graph

  learned_graph = nx.DiGraph(graph.causal_matrix)
  learned_graph.add_nodes_from(learned_graph.nodes())
  learned_graph.add_edges_from(learned_graph.edges())

  mapping = {i: labels[i] for i in learned_graph.nodes()}
  learned_graph = nx.relabel_nodes(learned_graph, mapping)
  pos = nx.circular_layout(learned_graph)

  pydot_graph = nx.drawing.nx_pydot.to_pydot(learned_graph)
  png_data = pydot_graph.create_png()
  if filename==None:
    display(Image(png_data))
  else:
    if filename[-3:]!="png" and filename[-3:]!="jpeg" and filename[-3:]!="pdf":
      filename+=".png"
    with open(filename, "wb") as f:
      f.write(png_data)

def delete_path(graph, labels, path_to_delete):

  """

  graph is a CausalGraph object

  labels: labels of the dataset

  path_to_delete: a list containing two nodes. For example ["Sex","Race"]. This will delete the path from "Sex" to "Race"

  """

  column_to_index = {col: i for i, col in enumerate(labels)}
  if path_to_delete[0] not in column_to_index.keys() or path_to_delete[1] not in column_to_index.keys():
    print("Error: given path is not in the labels for the data")
    return graph

  # Find the indices of the nodes
  node1_index = column_to_index[path_to_delete[0]]
  node2_index = column_to_index[path_to_delete[1]]

  graph.causal_matrix[node1_index, node2_index] = 0
  # Remove edge from node2 to node1, if it exists (uncomment the line below if you want that)
  # pc.causal_matrix[node2_to_disconnect, node1_to_disconnect] = 0

  return graph

def add_path(graph, labels, path_to_add):

  """

  graph is a CausalGraph object

  labels: labels of the dataset

  path_to_add: a list containing two nodes. For example ["Sex","Race"]. This will add the path from "Sex" to "Race"

  """

  column_to_index = {col: i for i, col in enumerate(labels)}
  if path_to_add[0] not in column_to_index.keys() or path_to_add[1] not in column_to_index.keys():
    print("Error: given path is not in the labels for the data")
    return graph

  # Find the indices of the nodes
  node1_index = column_to_index[path_to_add[0]]
  node2_index = column_to_index[path_to_add[1]]

  graph.causal_matrix[node1_index, node2_index] = 1
  # Remove edge from node2 to node1, if it exists (uncomment the line below if you want that)
  # pc.causal_matrix[node2_to_disconnect, node1_to_disconnect] = 0

  return graph

def run_pc_and_draw(file_path_data, variant="original", alpha=0.05, ci_test="fisherz", priori_knowledge=None, filename_graph = None):
  dataset, labels = load_and_check_data(file_path_data)
  g=run_pc(dataset, labels = labels, alpha=alpha, ci_test=ci_test, priori_knowledge = priori_knowledge)
  draw_graph(g, labels, filename_graph)
  return g

#file_path="adult_cleaned_bin.csv"
p=run_pc_and_draw(file_path, "original", 0.05, "fisherz", None, "static/image")

"""Now let's say we want to add background knowledge and put "income" in **Tier 1** and "marital status, race" in **Tier 2**"""

#file_path="adult_cleaned_bin.csv"
_,labels=load_and_check_data(file_path)
#background = [["income"], ["marital_status", "race"]]
#pc_with_background_knowledge=run_pc_and_draw(file_path,priori_knowledge=background)

"""Now, we want to delete the path from income to race"""

#pc_with_background_knowledge=delete_path(pc_with_background_knowledge, labels, ["income","race"])
#draw_graph(pc_with_background_knowledge, labels, filename=None)

"""Now, we we want to add a path from education to workclass"""

#pc_with_background_knowledge=add_path(pc_with_background_knowledge, labels, ["education","workclass"])
#draw_graph(pc_with_background_knowledge, labels, filename=None)

"""
# This is old and only kept for future reference

data

## PC Algorithm

x=data.columns[data.isna().any()].tolist()

pc = PC()
pc.learn(dataset)

learned_graph = nx.DiGraph(pc.causal_matrix)
learned_graph.add_nodes_from(learned_graph.nodes())
learned_graph.add_edges_from(learned_graph.edges())

# Relabel the nodes with column names
column_names = data.columns
mapping = {i: column_names[i] for i in learned_graph.nodes()}
learned_graph = nx.relabel_nodes(learned_graph, mapping)
pos = nx.circular_layout(learned_graph)

pydot_graph = nx.drawing.nx_pydot.to_pydot(learned_graph)

# Print the pydot graph
png_data = pydot_graph.create_png()
display(Image(png_data))

#Draw the graph:

pydot_graph = pydot.Dot(graph_type='digraph')

# Add nodes to the pydot graph
for node in learned_graph.nodes():
    pydot_node = pydot.Node(node)
    pydot_graph.add_node(pydot_node)

# Add edges to the pydot graph
for edge in learned_graph.edges():
    pydot_edge = pydot.Edge(edge[0], edge[1])
    pydot_graph.add_edge(pydot_edge)

# Set node positions for layout
for node, pos in pos.items():
    pydot_node = pydot_graph.get_node(node)[0]
    pydot_node.set_pos(f"{pos[0]},{pos[1]}")


# pydot_graph.write_png('learned_graph.png') # If you want to save the graph, uncomment this
png_data = pydot_graph.create_png()
display(Image(png_data))

# Adding Background Knowledge

(for example, we don't want any correlation between "workclass" and "Sex")


#Building priori knowledge object

priori = PrioriKnowledge(data.shape[1])
priori.add_forbidden_edge(data.columns.get_loc("Sex"), data.columns.get_loc("workclass"))
priori.add_forbidden_edge(data.columns.get_loc("workclass"), data.columns.get_loc("Sex"))

#Training a new PC Algorithm
pc = PC(priori_knowledge=priori)
pc.learn(dataset)
learned_graph = nx.DiGraph(pc.causal_matrix)
learned_graph.add_nodes_from(learned_graph.nodes())
learned_graph.add_edges_from(learned_graph.edges())

# Relabel the nodes with column names
column_names = data.columns
mapping = {i: column_names[i] for i in learned_graph.nodes()}
learned_graph = nx.relabel_nodes(learned_graph, mapping)
pos = nx.circular_layout(learned_graph)

#Drawing new graph

pydot_graph = pydot.Dot(graph_type='digraph')

# Add nodes to the pydot graph
for node in learned_graph.nodes():
    pydot_node = pydot.Node(node)
    pydot_graph.add_node(pydot_node)

# Add edges to the pydot graph
for edge in learned_graph.edges():
    pydot_edge = pydot.Edge(edge[0], edge[1])
    pydot_graph.add_edge(pydot_edge)

# Set node positions for layout
for node, pos in pos.items():
    pydot_node = pydot_graph.get_node(node)[0]
    pydot_node.set_pos(f"{pos[0]},{pos[1]}")


# pydot_graph.write_png('learned_graph.png') # If you want to save the graph, uncomment this
png_data = pydot_graph.create_png()
display(Image(png_data))

If the user wants to delete an edge, we modify the tensor data structure and generate new graph

column_to_index = {col: i for i, col in enumerate(data.columns)}
node1_to_disconnect = column_to_index['Sex']
node2_to_disconnect = column_to_index['race']
# Remove edge from node1 to node2
pc.causal_matrix[node1_to_disconnect, node2_to_disconnect] = 0
# Remove edge from node2 to node1, if it exists (uncomment the line below if you want that)
# pc.causal_matrix[node2_to_disconnect, node1_to_disconnect] = 0

learned_graph = nx.DiGraph(pc.causal_matrix)
learned_graph.add_nodes_from(learned_graph.nodes())
learned_graph.add_edges_from(learned_graph.edges())

# Relabel the nodes with column names
column_names = data.columns
mapping = {i: column_names[i] for i in learned_graph.nodes()}
learned_graph = nx.relabel_nodes(learned_graph, mapping)
pos = nx.circular_layout(learned_graph)

pydot_graph = pydot.Dot(graph_type='digraph')

# Add nodes to the pydot graph
for node in learned_graph.nodes():
    pydot_node = pydot.Node(node)
    pydot_graph.add_node(pydot_node)

# Add edges to the pydot graph
for edge in learned_graph.edges():
    pydot_edge = pydot.Edge(edge[0], edge[1])
    pydot_graph.add_edge(pydot_edge)

# Set node positions for layout
for node, pos in pos.items():
    pydot_node = pydot_graph.get_node(node)[0]
    pydot_node.set_pos(f"{pos[0]},{pos[1]}")


# pydot_graph.write_png('learned_graph.png') # If you want to save the graph, uncomment this
png_data = pydot_graph.create_png()
display(Image(png_data))
"""