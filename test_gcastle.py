# -*- coding: utf-8 -*-
"""Test_gcastle.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-8yyiMzRYtwZCzWBhV4MUcX2JeUgufqj

# Imports
"""


import os
os.environ['CASTLE_BACKEND'] = 'pytorch'

from collections import OrderedDict
from common.load_data import load_and_check_data
import numpy as np
import networkx as nx
import pandas as pd
import pydot
from IPython.display import Image, display

import castle
from castle.common import GraphDAG
from castle.metrics import MetricsDAG
from castle.datasets import IIDSimulation, DAG
from castle.algorithms import PC, GES, ICALiNGAM, GOLEM
from castle.common.priori_knowledge import PrioriKnowledge

import matplotlib.pyplot as plt
import dowhy
from dowhy import CausalModel
from graphviz import Digraph

import sys
import json

file_path = sys.argv[1] 
"""Get the data"""

#Loads dataset and checks if there are any NaN values and non numerical data
#Returns an np array of the values in the dataframe, and a list of labels



def run_pc(data, labels, variant="original", alpha=0.05, ci_test="fisherz", priori_knowledge=None):
  """
  data: a pd dataframe

  variant : str
  A variant of PC-algorithm, one of [`original`, `stable`, `parallel`].

  alpha: float, default 0.05  Significance level.

  ci_test : str, callable ci_test method, if str, must be one of [`fisherz`, `g2`, `chi2`]
  See more: `castle.common.independence_tests.CITest`

  priori_knowledge: PrioriKnowledge: a class object PrioriKnowledge. In this case, we will just use a list of lists, symbolizing tiers.

  For example: [["income", "relationship"],["Sex", "workclass"]]. The first sublist is tier 1, the second tier 2. No path from tier 2 to tier 1 can exist.
  """
  if priori_knowledge is not None:
    node_map = {}
    for i, label in enumerate(labels):
        node_map[label] = i
    priori = PrioriKnowledge(data.shape[1])

    for i in range(len(priori_knowledge) - 1, 0, -1):  # iterating through tiers in reverse order
        for j in range(len(priori_knowledge[i])):  # iterating through the nodes in the current tier
            for k in range(i - 1, -1, -1):  # iterate over the previous tiers in reverse order
                for p in range(len(priori_knowledge[k])):  # iterating through the previous tier nodes
                    priori.add_forbidden_edge(node_map[priori_knowledge[i][j]], node_map[priori_knowledge[k][p]])

    # Adding forbidden edges within the same tier
    for i in range(len(priori_knowledge)):
        for j in range(len(priori_knowledge[i]) - 1):
            for k in range(j + 1, len(priori_knowledge[i])):
                priori.add_forbidden_edge(node_map[priori_knowledge[i][j]], node_map[priori_knowledge[i][k]])
  else:
    priori = None


  pc = PC(variant = variant, alpha = alpha, ci_test = ci_test, priori_knowledge = priori)
  pc.learn(data)
  return pc

def draw_graph(graph, labels, filename=None): # Draw the pydot graph

  adjacency_matrix = graph.causal_matrix
  learned_graph = nx.DiGraph()
  undirected_paths = set() # Set to check if we have undirected_paths

  # Add directed edges based on the condition
  for i in range(len(adjacency_matrix)):
    for j in range(len(adjacency_matrix[0])):
      if adjacency_matrix[i][j] == 1 and adjacency_matrix[j][i] == 0:
        learned_graph.add_edge(labels[i], labels[j])
      elif (adjacency_matrix[i][j] == 1 and adjacency_matrix[j][i] == 1) and ((labels[i],labels[j]) not in undirected_paths and (labels[j],labels[i]) not in undirected_paths):
        learned_graph.add_edge(labels[i], labels[j], style="dashed", arrowhead="none")
        undirected_paths.add((labels[i],labels[j]))

  pos = nx.circular_layout(learned_graph)
  pydot_graph = nx.drawing.nx_pydot.to_pydot(learned_graph)

  png_data = pydot_graph.create_png()
  if filename==None:
    display(Image(png_data))
  else:
    if filename[-3:]!="png" and filename[-3:]!="jpeg" and filename[-3:]!="pdf":
      filename+=".png"
    with open(filename, "wb") as f:
      f.write(png_data)

def delete_path(graph, labels, path_to_delete):

  """

  graph is a CausalGraph object

  labels: labels of the dataset

  path_to_delete: a list containing two nodes. For example ["Sex","Race"]. This will delete the path from "Sex" to "Race"

  """

  column_to_index = {col: i for i, col in enumerate(labels)}
  if path_to_delete[0] not in column_to_index.keys() or path_to_delete[1] not in column_to_index.keys():
    print("Error: given path is not in the labels for the data")
    return graph

  # Find the indices of the nodes
  node1_index = column_to_index[path_to_delete[0]]
  node2_index = column_to_index[path_to_delete[1]]

  graph.causal_matrix[node1_index, node2_index] = 0
  # Remove edge from node2 to node1, if it exists (uncomment the line below if you want that)
  # pc.causal_matrix[node2_to_disconnect, node1_to_disconnect] = 0

  return graph

def add_path(graph, labels, path_to_add):

  """

  graph is a CausalGraph object

  labels: labels of the dataset

  path_to_add: a list containing two nodes. For example ["Sex","Race"]. This will add the path from "Sex" to "Race"

  """

  column_to_index = {col: i for i, col in enumerate(labels)}
  if path_to_add[0] not in column_to_index.keys() or path_to_add[1] not in column_to_index.keys():
    print("Error: given path is not in the labels for the data")
    return graph

  # Find the indices of the nodes
  node1_index = column_to_index[path_to_add[0]]
  node2_index = column_to_index[path_to_add[1]]

  graph.causal_matrix[node1_index, node2_index] = 1
  # Remove edge from node2 to node1, if it exists (uncomment the line below if you want that)
  # pc.causal_matrix[node2_to_disconnect, node1_to_disconnect] = 0

  return graph

def run_pc_and_draw(file_path_data, variant="original", alpha=0.05, ci_test="fisherz", priori_knowledge=None, filename_graph = None):
  dataset, labels = load_and_check_data(file_path_data)
  g=run_pc(dataset, labels = labels, alpha=alpha, ci_test=ci_test, priori_knowledge = priori_knowledge)

  graph_operations_list = []
  if len(sys.argv) > 2 and len(sys.argv[2]) > 0:
    graph_operations_list = json.loads(sys.argv[2])

  if len(graph_operations_list) > 0:
     print(graph_operations_list)
     for i in range(len(graph_operations_list)): 
        if graph_operations_list[i]["op"] == "add":
          add_path(g, labels, [graph_operations_list[i]["start"], graph_operations_list[i]["end"]])
        if graph_operations_list[i]["op"] == "delete":
          delete_path(g, labels, [graph_operations_list[i]["start"], graph_operations_list[i]["end"]])
   # add_path(g, labels, [sys.argv[2], sys.argv[3]])
  #if len(sys.argv) > 2 and sys.argv[4] and len(sys.argv[4]) > 1 and sys.argv[5] and len(sys.argv[5]):
   # delete_path(g, labels, [sys.argv[4], sys.argv[5]])
  draw_graph(g, labels, filename_graph)
  return g


p=run_pc_and_draw(file_path, "original", 0.05, "fisherz", None, "static/image")
print("hahahahha")

"""Now let's say we want to add background knowledge and put "income" in **Tier 1** and "marital status, race" in **Tier 2**"""

_,labels=load_and_check_data(file_path)

